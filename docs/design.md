# Design Decisions


## Stage 1: Database Schema Design

### Normalization & Structure
Hybrid normalization with core tables (students, scholarships) and junction tables for many-to-many relationships. Simple eligibility criteria stored as nullable columns; array-based criteria in junction tables. Junction tables use composite primary keys.

**Rationale:** Core data in main tables for clarity; junction tables enable better indexing and querying than arrays/JSONB. Nullable columns allow optional criteria (NULL = not required).

### Data Types & Constraints
- IDs: VARCHAR(50) preserving format ("stu_001", "sch_001")
- GPA: DECIMAL(3,2) with CHECK constraint (0.0-4.0)
- Amounts: INTEGER (whole dollars)
- Dates: DATE for deadlines, TIMESTAMP for created_at/updated_at
- Arrays: TEXT[] for application_requirements (read-only reference data)

### Indexing Strategy
Comprehensive indexes on all matching query fields (student: gpa, enrollment_status, citizenship_status, major, financial_need, etc.; scholarship: gpa_minimum, first_generation, etc.). Junction table indexes on both foreign key sides.

**Rationale:** Matching queries filter on multiple criteria simultaneously. Indexes enable fast EXISTS/IN subquery performance.

### Empty Array Handling
Empty arrays in JSON result in no rows in junction table (empty = all eligible, no restrictions applied).

**Rationale:** Consistent pattern: no rows = no filter. Matches design assumption that empty arrays mean "no restrictions".



## stage 2: API Implementation Design

### Architecture Pattern
Service layer architecture with separation of concerns: routes handle HTTP, services handle business logic. Express app with centralized error handling middleware. TypeScript for type safety.

**Rationale:** Maintainable structure with clear separation. Services are reusable, routes focus on request/response handling.

### Error Handling
Centralized error middleware with PostgreSQL error code detection (23xxx for conflicts, 22xxx for validation). Custom ValidationError class for request validation. Consistent JSON error responses with appropriate HTTP status codes.

### Matching Logic
Single comprehensive SQL query using EXISTS clauses for junction table checks. Handles NULL eligibility criteria (NULL = not required) and empty junction tables (empty = all eligible). Match reasons generated by analyzing which criteria were required and met.

**Rationale:** Efficient single-query approach. EXISTS clauses optimized by PostgreSQL. Clear feedback focuses on required criteria only.

### Financial Need & ID Generation
Financial need calculated in application code (household_income < $50,000). Student IDs generated sequentially by querying max existing ID. Both stored in database for query performance.

**Rationale:** Business logic in application code is easier to test and modify. Database stores results for efficient queries.